package server_test

import (
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/piwi3910/netweave/internal/server"

	"github.com/gin-gonic/gin"
	"github.com/piwi3910/netweave/internal/dms/adapter"
	dmshandlers "github.com/piwi3910/netweave/internal/dms/handlers"
	dmsregistry "github.com/piwi3910/netweave/internal/dms/registry"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap"
)

// Sentinel error for testing.
var errNotImplemented = errors.New("not implemented in mock")

// mockDMSAdapter implements adapter.DMSAdapter for testing.
type mockDMSAdapter struct {
	name         string
	version      string
	capabilities []adapter.Capability
}

func newMockDMSAdapter() *mockDMSAdapter {
	return &mockDMSAdapter{
		name:         "test-adapter",
		version:      "1.0.0",
		capabilities: []adapter.Capability{adapter.CapabilityDeploymentLifecycle},
	}
}

func (m *mockDMSAdapter) Name() string                       { return m.name }
func (m *mockDMSAdapter) Version() string                    { return m.version }
func (m *mockDMSAdapter) Capabilities() []adapter.Capability { return m.capabilities }

func (m *mockDMSAdapter) ListDeploymentPackages(
	_ context.Context,
	_ *adapter.Filter,
) ([]*adapter.DeploymentPackage, error) {
	return []*adapter.DeploymentPackage{}, nil
}
func (m *mockDMSAdapter) GetDeploymentPackage(_ context.Context, _ string) (*adapter.DeploymentPackage, error) {
	return nil, errNotImplemented
}
func (m *mockDMSAdapter) UploadDeploymentPackage(
	_ context.Context,
	_ *adapter.DeploymentPackageUpload,
) (*adapter.DeploymentPackage, error) {
	return nil, errNotImplemented
}
func (m *mockDMSAdapter) DeleteDeploymentPackage(_ context.Context, _ string) error { return nil }
func (m *mockDMSAdapter) ListDeployments(_ context.Context, _ *adapter.Filter) ([]*adapter.Deployment, error) {
	return []*adapter.Deployment{}, nil
}
func (m *mockDMSAdapter) GetDeployment(_ context.Context, _ string) (*adapter.Deployment, error) {
	return nil, errNotImplemented
}
func (m *mockDMSAdapter) CreateDeployment(
	_ context.Context,
	_ *adapter.DeploymentRequest,
) (*adapter.Deployment, error) {
	return nil, errNotImplemented
}
func (m *mockDMSAdapter) UpdateDeployment(
	_ context.Context,
	_ string,
	_ *adapter.DeploymentUpdate,
) (*adapter.Deployment, error) {
	return nil, errNotImplemented
}
func (m *mockDMSAdapter) DeleteDeployment(_ context.Context, _ string) error { return nil }
func (m *mockDMSAdapter) ScaleDeployment(_ context.Context, _ string, _ int) error {
	return nil
}
func (m *mockDMSAdapter) RollbackDeployment(_ context.Context, _ string, _ int) error {
	return nil
}
func (m *mockDMSAdapter) GetDeploymentStatus(_ context.Context, _ string) (*adapter.DeploymentStatusDetail, error) {
	return nil, errNotImplemented
}
func (m *mockDMSAdapter) GetDeploymentHistory(_ context.Context, _ string) (*adapter.DeploymentHistory, error) {
	return nil, errNotImplemented
}
func (m *mockDMSAdapter) GetDeploymentLogs(_ context.Context, _ string, _ *adapter.LogOptions) ([]byte, error) {
	return nil, errNotImplemented
}
func (m *mockDMSAdapter) SupportsRollback() bool         { return true }
func (m *mockDMSAdapter) SupportsScaling() bool          { return true }
func (m *mockDMSAdapter) SupportsGitOps() bool           { return false }
func (m *mockDMSAdapter) Health(_ context.Context) error { return nil }
func (m *mockDMSAdapter) Close() error                   { return nil }

// setupTestServer creates a minimal test server.server with DMS routes.
func setupTestServer(t *testing.T) *server.Server {
	t.Helper()

	gin.SetMode(gin.TestMode)
	logger := zap.NewNop()

	router := gin.New()

	srv := server.NewTestServerWithRouter(router, logger)

	return srv
}

func TestHandleDMSAPIInfo(t *testing.T) {
	srv := setupTestServer(t)

	// Set up the route directly.
	srv.Router().GET("/o2dms", srv.HandleDMSAPIInfo)

	req := httptest.NewRequest(http.MethodGet, "/o2dms", nil)
	w := httptest.NewRecorder()

	srv.Router().ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, "v1", response["api_version"])
	assert.Equal(t, "/o2dms/v1", response["base_path"])
	assert.Equal(t, "O-RAN O2-DMS (Deployment Management Service) API", response["description"])

	resources, ok := response["resources"].([]interface{})
	require.True(t, ok)
	assert.Len(t, resources, 4)
	assert.Contains(t, resources, "deploymentLifecycle")
	assert.Contains(t, resources, "nfDeployments")
	assert.Contains(t, resources, "nfDeploymentDescriptors")
	assert.Contains(t, resources, "subscriptions")

	operations, ok := response["operations"].([]interface{})
	require.True(t, ok)
	assert.Len(t, operations, 6)
	assert.Contains(t, operations, "instantiate")
	assert.Contains(t, operations, "terminate")
	assert.Contains(t, operations, "scale")
	assert.Contains(t, operations, "heal")
	assert.Contains(t, operations, "upgrade")
	assert.Contains(t, operations, "rollback")
}

func TestSetupDMSRoutes(t *testing.T) {
	srv := setupTestServer(t)
	logger := zap.NewNop()

	// Create a registry with a mock adapter.
	reg := dmsregistry.NewRegistry(logger, nil)
	mockAdp := newMockDMSAdapter("test-adapter")
	err := reg.Register(context.Background(), "test-adapter", "mock", mockAdp, nil, true)
	require.NoError(t, err)

	// Set up DMS using the server.server method.
	srv.SetupDMS(reg)

	// Verify all routes are registered by checking each endpoint.
	routes := srv.Router().Routes()
	routePaths := make(map[string][]string)
	for _, r := range routes {
		routePaths[r.Path] = append(routePaths[r.Path], r.Method)
	}

	// Check main DMS info endpoint.
	assert.Contains(t, routePaths["/o2dms"], http.MethodGet)

	// Check deployment lifecycle endpoint.
	assert.Contains(t, routePaths["/o2dms/v1/deploymentLifecycle"], http.MethodGet)

	// Check nfDeployments endpoints.
	assert.Contains(t, routePaths["/o2dms/v1/nfDeployments"], http.MethodGet)
	assert.Contains(t, routePaths["/o2dms/v1/nfDeployments"], "POST")
	assert.Contains(t, routePaths["/o2dms/v1/nfDeployments/:nfDeploymentId"], http.MethodGet)
	assert.Contains(t, routePaths["/o2dms/v1/nfDeployments/:nfDeploymentId"], "PUT")
	assert.Contains(t, routePaths["/o2dms/v1/nfDeployments/:nfDeploymentId"], "DELETE")
	assert.Contains(t, routePaths["/o2dms/v1/nfDeployments/:nfDeploymentId/scale"], "POST")
	assert.Contains(t, routePaths["/o2dms/v1/nfDeployments/:nfDeploymentId/rollback"], "POST")
	assert.Contains(t, routePaths["/o2dms/v1/nfDeployments/:nfDeploymentId/status"], http.MethodGet)
	assert.Contains(t, routePaths["/o2dms/v1/nfDeployments/:nfDeploymentId/history"], http.MethodGet)

	// Check nfDeploymentDescriptors endpoints.
	assert.Contains(t, routePaths["/o2dms/v1/nfDeploymentDescriptors"], http.MethodGet)
	assert.Contains(t, routePaths["/o2dms/v1/nfDeploymentDescriptors"], "POST")
	assert.Contains(t, routePaths["/o2dms/v1/nfDeploymentDescriptors/:nfDeploymentDescriptorId"], http.MethodGet)
	assert.Contains(t, routePaths["/o2dms/v1/nfDeploymentDescriptors/:nfDeploymentDescriptorId"], "DELETE")

	// Check subscriptions endpoints.
	assert.Contains(t, routePaths["/o2dms/v1/subscriptions"], http.MethodGet)
	assert.Contains(t, routePaths["/o2dms/v1/subscriptions"], "POST")
	assert.Contains(t, routePaths["/o2dms/v1/subscriptions/:subscriptionId"], http.MethodGet)
	assert.Contains(t, routePaths["/o2dms/v1/subscriptions/:subscriptionId"], "DELETE")
}

func TestDMSRoutesIntegration(t *testing.T) {
	srv := setupTestServer(t)
	logger := zap.NewNop()

	// Create a registry with a mock adapter.
	reg := dmsregistry.NewRegistry(logger, nil)
	mockAdp := newMockDMSAdapter("test-adapter")
	err := reg.Register(context.Background(), "test-adapter", "mock", mockAdp, nil, true)
	require.NoError(t, err)

	// Set up DMS.
	srv.SetupDMS(reg)

	// Test that we can hit each endpoint type.
	testCases := []struct {
		name           string
		method         string
		path           string
		expectedStatus int
	}{
		{
			name:           "DMS API info",
			method:         http.MethodGet,
			path:           "/o2dms",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "Deployment lifecycle info",
			method:         http.MethodGet,
			path:           "/o2dms/v1/deploymentLifecycle",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "List NF deployments",
			method:         http.MethodGet,
			path:           "/o2dms/v1/nfDeployments",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "List NF deployment descriptors",
			method:         http.MethodGet,
			path:           "/o2dms/v1/nfDeploymentDescriptors",
			expectedStatus: http.StatusOK,
		},
		{
			name:           "List DMS subscriptions",
			method:         http.MethodGet,
			path:           "/o2dms/v1/subscriptions",
			expectedStatus: http.StatusOK,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			req := httptest.NewRequest(tc.method, tc.path, nil)
			w := httptest.NewRecorder()

			srv.Router().ServeHTTP(w, req)

			assert.Equal(t, tc.expectedStatus, w.Code, "Unexpected status for %s %s", tc.method, tc.path)
		})
	}
}

func TestDMSRegistry(t *testing.T) {
	srv := setupTestServer(t)
	logger := zap.NewNop()

	// Initially should be nil.
	assert.Nil(t, srv.DMSRegistry())

	// Create and set up DMS.
	reg := dmsregistry.NewRegistry(logger, nil)
	srv.SetupDMS(reg)

	// Now should return the registry.
	assert.NotNil(t, srv.DMSRegistry())
	assert.Equal(t, reg, srv.DMSRegistry())
}

// TestDMSV2Routes verifies that v2 routes are registered and respond.
func TestDMSV2Routes(t *testing.T) {
	gin.SetMode(gin.TestMode)
	router := gin.New()

	logger := zap.NewNop()
	registry := dmsregistry.NewRegistry(logger, nil)

	mockAdapter := newMockDMSAdapter("test-adapter")
	err := registry.Register(context.Background(), "test-adapter", "mock", mockAdapter, nil, true)
	require.NoError(t, err)

	// Setup handler
	handler := dmshandlers.NewHandler(registry, nil, logger)

	// Set up v2 routes manually
	v2 := router.Group("/o2dms/v2")
	v2.GET("/deploymentLifecycle", handler.GetDeploymentLifecycleInfo)

	// Add v2 features endpoint
	v2.GET("/features", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"version":     "v2",
			"apiVersion":  "v2",
			"description": "O2-DMS API v2 with enhanced filtering, batch operations",
			"newFeatures": []string{
				"enhanced_filtering",
				"batch_deployments",
			},
		})
	})

	// Test v2 features endpoint.
	req, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, "/o2dms/v2/features", nil)
	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	var response map[string]interface{}
	err = json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "v2", response["version"])
	assert.Contains(t, response, "newFeatures")

	// Test that v2 includes v1 routes (deployment lifecycle info).
	req, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, "/o2dms/v2/deploymentLifecycle", nil)
	w = httptest.NewRecorder()
	router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code)
}

// TestDMSV3Routes verifies that v3 routes are registered and respond.
func TestDMSV3Routes(t *testing.T) {
	gin.SetMode(gin.TestMode)
	router := gin.New()

	logger := zap.NewNop()
	registry := dmsregistry.NewRegistry(logger, nil)

	mockAdapter := newMockDMSAdapter("test-adapter")
	err := registry.Register(context.Background(), "test-adapter", "mock", mockAdapter, nil, true)
	require.NoError(t, err)

	// Setup handler
	handler := dmshandlers.NewHandler(registry, nil, logger)

	// Set up v3 routes manually
	v3 := router.Group("/o2dms/v3")
	v3.GET("/nfDeployments", handler.ListNFDeployments)

	// Add v3 features endpoint
	v3.GET("/features", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"version":     "v3",
			"apiVersion":  "v3",
			"description": "O2-DMS API v3 with multi-tenancy support",
			"newFeatures": []string{
				"multi_tenancy",
				"tenant_quotas",
			},
		})
	})

	// Test v3 features endpoint.
	req, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, "/o2dms/v3/features", nil)
	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
	var response map[string]interface{}
	err = json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "v3", response["version"])
	assert.Contains(t, response, "newFeatures")

	// Test that v3 includes v1 routes.
	req, _ = http.NewRequestWithContext(context.Background(), http.MethodGet, "/o2dms/v3/nfDeployments", nil)
	w = httptest.NewRecorder()
	router.ServeHTTP(w, req)
	// Should work (returns 200 with empty list from mock adapter).
	assert.Equal(t, http.StatusOK, w.Code)
}
